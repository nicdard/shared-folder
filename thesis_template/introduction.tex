\chapter{Introduction}


\section{Motivation}

File storage over public cloud providing also sharing capabilities is a common service used by many people and organizations.
Some notable examples of such services in the wild are Dropbox, Google Drive, One Drive, iCloud, Mega, etc.
Interestingly, only some of the major solutions provide end-to-end encryption (E2EE) for the user uploading 
the data, normally only to premium or enterprise users.\cite{Dropbox}\cite{googleWorkspaceE2EE}\cite{Apple}\cite{Mega}
This security feature is rather new and adopted only lately by the major players in the market.
Taking a step further, we can generalise the concept of files to any data a group of users want to share.
Thus we can expand the scope to cloud storage services like AWS S3, Azure Blob Storage, Google Cloud Storage, etc.
Sharing capabilities are not normally supported by default in these systems, but can be built on top of them.

The popularity of cloud storage services has increased in the last decades,
and projections are showing that they will store around 50\% of the global data by 2025.
This amounts to around 100 zettabytes.\cite{SteveMorgan}
Given this enourmous data and wide range of users, we believe cloud storage security is a major topic to investigate in terms of security.

The study of E2EE cloud storage has not been widely explored yet in the literature until very recent times compared to messaging applications.\cite{EPRINT:BDGHP24}
Messaging applications however can be taken as a starting point, as they present similar security issues.
These are nowdays the de facto standard for communication.
Normally messages are routed through centralized provider's servers before reaching the recipient.
Modern instant messaging apps like Signal, WhatsApp, Telegram, etc. 
have implemented E2EE to protect the content of the messages from the server.
The Signal protocol established forward security (FS) and post compromise security (PCS)
properties as standard in this setting, where the core attention is given to the data in transit,
given that messages are \textbf{ephemeral} in nature. 
Later, messaging layer security (MLS) protocol lifted the same security properties to asynchronous
group communications.

In the cloud storage setting, the services assure no persistent data is lost.
\footnote{Normally through service level agreements, legal contracts stating the probability of data loss in a specified amount of time, which is assured to be less than a certain number, such as 99.999...\%. This probability usually usually a lot of 9s.} 
Moreover, the data is normally replicated, to assure both persistency and availability.
\footnote{Availability is also assured by other means, but replicating the data generally helps in scaling out the system and serving the data when receiving multiple concurrent requests. In general indeed, a file is written through a unique primary node (to which the file is assigned) and then replicated across ``read replicas'', nodes that are then used to serve read requests.}
The \texttt{persistence} of the data poses difficulties in designing a protocol that guarantee PCS and FS in these systems.
In \cref{sc:file-sharing-security-notions}, we describe briefly a study conducted on the possible similar achiavable security guarantess for data at rest, which forms the theoretical ground of this thesis.

The focus of this work is to take a step further from the aforementioned stufy, 
and implement a fully functioning system based on the novel theory and theoretical constructions.
In \cref{sc:focus-of-this-thesis} we describe the focus of this work in more details.
The implementation has been conducted partially in the timeframe when the protocol was designed, to bridge the theoretical side with a more practical engineering view.


\section{File Sharing Security Notions}\label{sc:file-sharing-security-notions}

The research group made of Matilda Backendal from ETH Zurich,
David Balb{\'a}s from IMDEA Software Institute and Universidad Polit{\'e}cnica de Madrid 
and Miro Haller from UC San Diego propose two novel security notions for shared data in
a dynamic group of users: 
\begin{itemize}
    \item PAS: \textit{past access security}, describing how data created before the legitimate access of a user starts is protected.
    \item FAS: \textit{future access security}, descibing how data created after the legitimate access of a user ends is protected.
\end{itemize}
Those properties are bound to both the lifetime of the data at rest and the legitimate access of a user.
The properties can be seen as analougous to FS and PCS respectively, but for persistent data.

A new \textit{group key progression} scheme is designed to meet the security notions above,
allowing an evolving group of users with admins to derive a sequence of keys efficiently from a compact state. 
This scheme is using primitives from secure group messaging, 
specifially a version of continuous key group agreement (CGKA) supporting admins.\cite{USENIX:BalColVau23}
In the following we will call an application of the group key progression ``Secure Shared Folder'' (SSF)
where we will use the group key progression to manage the state of a shared folder containing multiple files. 

\section{Focus of this Thesis}\label{sc:focus-of-this-thesis}

The focus of this work is the implementation of the proposed theoritical solution (\cref{sc:file-sharing-security-notions}),
closing the gaps between the abstract logical world of the proposed scheme
and the actual real-world system.
The implementation is conducted following the best engeeniring practices 
and guarantee the security expressed in the theoritical design.
A great attention is given to the real-world aspect of this implementation,
posing challenges that would be otherwise uncovered in just a proof-of-concept implementation.
The final outcome of the engineering work is primarly a minimal viable product (MVP) executing the protocol.
To this end the engineering work is divided into two main parts:
\begin{itemize}
    \item The implementation of all of the infrastructure needed to simulate a real system.
    \item The implementation of the client protocol.
\end{itemize}

\section{Summary of Contributions}\label{sc:summary-of-contributions}

We implement an MVP running the secure shared folder scheme (SSF) and a baseline implementation:

\begin{enumerate}
    \item We show how targeting a real-world setting is beneficial to the cryptographic community and its research, driving questions and possible solutions. A synergy between cryptographers and practicioners is beneficial and needed to both. It would help to reduce the number of vulnerabilities normally found in software we use everyday and help design ecosystems to develop better and more secure software. Writing cryptographic software is really hard and any mistake can corrupt the security of the overall system. We think that this work shows how cryptography should really take care of the actual runtime environment and many other engineering problems in formalisations. These cannot be simply left as implementation details, as (even good) software engineers normally lack the knowledge to address such decisions. This might influence the correcteness of the system and break its security guarantees.
    \item We survey the major problems arising while translating the scheme into a concrete, deployable artifact. In particular, we list the ``Engineering Gaps'' that are uncovered with this work. This term refers to the problems that are not normally addressed in the theoritical design, but are crucial to the success of the implementation.
    \item We discover and fix two major bugs in the constructions which are the building blocks of the SSF scheme. Together with our fix, we provide a detailed explanation of the cause of the bugs and propose a extension of the underlying primitives to better model and cover the problematic cases.
\end{enumerate}

This thesis also contains several side contributions, which might be of interest to
practicioners embarking on a similar implementation journey:
\begin{enumerate}
    \item We provide an in-depth description of the project setup, and detail the interoperability between programming languages, tools and libraries used, as well as organization of our automated tests and component virtualization. The usage of several technologies together made the implementation possible in a restricted timeframe by a single developer, we believe this can be of great interest to many other developers, also for projects outside the crypto space. \nd{I could add an appendix (and link it here) with the various technologies and where they are applied / how they are used together?}
    \item We provide a detailed description of our usage of the WebCrypto API to construct the cryptographic primitives needed to run the protocol. Similar techniques could be used to implement other cryptographic primitives normally found in the literature but not directly available in the browser. We also document portability issues we discovered in the Web Crypto API implementations across different runtimes. Further, we provide the code for the workaround we implemented to solve them.
    \item We give open source access to the codebase for further research and development.\footnote{The code will be made public as soon as the related research work is also of public domain.}
\end{enumerate}

\section{Outline}

In \cref{ch:background} we give a brief overview of the background, particularly 
we present the cryptographic primitives that are used in the theoretical construction 
as well as the SSF scheme itself. We also briefly discuss related work. 

The main contributions are then presented, divided as follows: 
in \cref{ch:setup} we describe the setup and technologies chosen for the implementation of both the baseline and the SSF scheme. We mainly describe the common choices here, while going into more details leter on in \cref{ch:baseline} and \cref{ch:ssf} for the specific choices in the two cases.
In \cref{ch:baseline} we describe the baseline implementation, its protocol and architectural design.
In \cref{ch:ssf} we describe the SSF implementation. We recap the theoretical construction and then describe the architectural design and the differences in the actual protocol.
In \cref{ch:gaps} we describe the gaps uncovered during the implementation. This will provide the reader with all the lesson learnt through this project, and is built on top of all the previous core chapters.

Researchers interested in exploring how their assumptions can impact the system in a real-world setting and explore their implications can primarily read \cref{ch:gaps}, and follow the references to the other chapters as needed.
Readers mostly interested in the implementation of the SSF scheme, as a complement to the Backendal et al. paper~\cite{GKP}, can read \cref{ch:ssf}. Again, backward references are provided to the relevant background section and system design chapters, so it should be easy to navigate the document.
Practicioners could instead focus primarily on \cref{ch:setup}, especially in the technology survey paragraphs which are interleaved to the system description. They can also read about some suggestions and practical lesson learnt in \cref{sc:gap-type-safety-of-opaque-byte-arrays}
