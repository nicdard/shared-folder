use rocket_db_pools::{sqlx, Connection, Database};
use sqlx::{mysql::MySqlQueryResult, Acquire};

/// The database connection pool.
// https://api.rocket.rs/v0.5/rocket_db_pools/
#[derive(Database)]
#[database("ds")]
pub struct DbConn(pub sqlx::MySqlPool);

#[derive(sqlx::FromRow, Clone, Debug)]
pub struct UserEntity {
    pub user_email: String,
}

#[derive(sqlx::FromRow, Debug)]
pub struct FolderEntity {
    /// The id of the folder, auto-generated by the DB.
    pub folder_id: u64,
    /// The name of the folder. Multiple users can create folders with the same name.
    pub folder_name: String,
}

pub type DbConnection = Connection<DbConn>;

/// The number of parameters in MySQL must fit in a `u16`.
const BIND_LIMIT: usize = 65535;

/// Get the user by the email from the database.
pub async fn get_user_by_email(
    email: &str,
    mut db: Connection<DbConn>,
) -> Result<UserEntity, sqlx::Error> {
    sqlx::query_as::<_, UserEntity>("SELECT * FROM users WHERE user_email = ?")
        .bind(&email)
        .fetch_one(&mut **db)
        .await
}

/// Insert the user in the database.
pub async fn insert_user(email: &str, mut db: Connection<DbConn>) -> Result<(), sqlx::Error> {
    sqlx::query("INSERT INTO users (user_email) VALUES (?)")
        .bind(&email)
        .execute(&mut **db)
        .await
        .map(|_| ())
}

/// List all the users from the database.
pub async fn list_users(mut db: Connection<DbConn>) -> Result<Vec<UserEntity>, sqlx::Error> {
    sqlx::query_as::<_, UserEntity>("SELECT * FROM users")
        .fetch_all(&mut **db)
        .await
}

/// Get the folder by the name from the database.
pub async fn get_folder_for_name(
    name: &str,
    mut db: Connection<DbConn>,
) -> Result<FolderEntity, sqlx::Error> {
    sqlx::query_as::<_, FolderEntity>("SELECT * FROM folders WHERE name = ?")
        .bind(&name)
        .fetch_one(&mut **db)
        .await
}

/// List all the folders for a user from the database.
pub async fn list_folders_by_user(
    email: &str,
    mut db: Connection<DbConn>,
) -> Result<Vec<FolderEntity>, sqlx::Error> {
    sqlx::query_as::<_, FolderEntity>(
        "SELECT * FROM folders JOIN folders_users ON(folder_id) JOIN users ON(user_name) WHERE users.user_email = ?)",
    )
    .bind(&email)
    .fetch_all(&mut **db)
    .await
}

/// Create a folder and attach it to some users.
pub async fn insert_folder_and_relations(
    folder_name: &str,
    user_emails: &Vec<&str>,
    mut db: Connection<DbConn>,
) -> Result<(), impl std::error::Error> {
    let mut transaction = db.begin().await?;
    let user_email: Vec<String> = get_users_by_emails(user_emails, &mut transaction)
        .await?
        .into_iter()
        .map(|user: UserEntity| user.user_email)
        .collect();
    // TODO: check that the folder_name is not already connected to any recipient.
    let folder_id = insert_folder(folder_name, &mut transaction)
        .await?
        .last_insert_id();
    insert_folders_to_users(folder_id, &user_email, &mut transaction).await
    // The transaction is ended implicitely when the `transaction` object is dropped.
}

/// Safely get all [`UserEntity`] by their emails.
/// If the array of users is to big, the query will be chunked.
pub async fn get_users_by_emails(
    user_emails: &Vec<&str>,
    transaction: &mut sqlx::Transaction<'_, sqlx::MySql>,
) -> Result<Vec<UserEntity>, sqlx::Error> {
    let chunks = user_emails.chunks(BIND_LIMIT);
    let mut users = Vec::with_capacity(user_emails.capacity());
    for chunk in chunks {
        let result = unsafe_get_users_by_emails(chunk, transaction).await;
        if let Ok(to_add) = result {
            users.extend(to_add);
        } else {
            return result;
        }
    }
    Ok(users)
}

/// Get the list of user ids given the emails
/// Note: You should limit the number of values to the maximum supported value in MySQL!
/// Use [`get_users_by_emails`] instead
async fn unsafe_get_users_by_emails(
    user_emails: &[&str],
    transaction: &mut sqlx::Transaction<'_, sqlx::MySql>,
) -> Result<Vec<UserEntity>, sqlx::Error> {
    let mut query_builder = sqlx::QueryBuilder::new("SELECT * FROM users WHERE (email) IN");
    query_builder.push_tuples(user_emails, |mut b, user_email| {
        b.push_bind(user_email);
    });
    let query = query_builder.build_query_as::<UserEntity>();
    query.fetch_all(&mut **transaction).await
}

/// Insert the folder in the database.
async fn insert_folder(
    name: &str,
    transaction: &mut sqlx::Transaction<'_, sqlx::MySql>,
) -> Result<MySqlQueryResult, sqlx::Error> {
    sqlx::query("INSERT INTO folders (name) VALUES (?)")
        .bind(&name)
        .execute(&mut **transaction)
        .await
}

/// Insert a row inside the relations `folder_users` table for each of the user_id.
async fn insert_folders_to_users(
    folder_id: u64,
    user_emails: &Vec<String>,
    transaction: &mut sqlx::Transaction<'_, sqlx::MySql>,
) -> Result<(), sqlx::Error> {
    let chunks = user_emails.chunks(BIND_LIMIT);
    for chunk in chunks {
        let result = unsafe_insert_folders_to_users(folder_id, chunk, transaction).await;
        if result.is_err() {
            return result;
        }
    }
    Ok(())
}

/// Insert multiple relationship between folder and users.
/// Note: You should limit the number of values to the maximum supported value in MySQL!
/// Use [`insert_folders_to_users`](insert_folders_to_users) instead
async fn unsafe_insert_folders_to_users(
    folder_id: u64,
    user_emails: &[String],
    transaction: &mut sqlx::Transaction<'_, sqlx::MySql>,
) -> Result<(), sqlx::Error> {
    let values = user_emails.iter().map(|user_email| (folder_id, user_email));
    let mut query_builder =
        sqlx::QueryBuilder::new("INSERT INTO folders_users(folder_name, user_email)");
    let query = query_builder
        .push_values(values, |mut b, (folder_id, user_email)| {
            b.push_bind(folder_id).push_bind(user_email);
        })
        .build();
    query.execute(&mut **transaction).await.map(|_| ())
}

/// Delete the user from the database.
async fn delete_user(email: &str, mut db: Connection<DbConn>) -> Result<(), sqlx::Error> {
    sqlx::query("DELETE FROM users WHERE email = ?")
        .bind(&email)
        .execute(&mut **db)
        .await
        .map(|_| ())
}
